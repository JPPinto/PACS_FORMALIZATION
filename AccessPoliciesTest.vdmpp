class AccessPoliciesTest

	instance variables
		
	operations
		-- Simulates assertion checking by reducing it to pre-condition checking.
		-- If 'arg' does not hold, a pre-condition violation will be signaled.
		protected assertTrue: bool ==> ()
		assertTrue(arg) == return pre arg;

		-- Simulates assertion checking by reducing it to post-condition checking.
		-- If values are not equal, prints a message in the console and generates
		-- a post-conditions violation.
		protected assertEqual: ? * ? ==> ()
		assertEqual(expected, actual) == if expected <> actual then (
			IO`print("Actual value (");
			IO`print(actual);
			IO`print(") different from expected (");
			IO`print(expected);
			IO`println(")\n")
		)
		post expected = actual;
		
		-- Configure expirable cards scenario
		public configureCardsScenario: Facility * map nat to DateUtil`Date ==> set of Card
		configureCardsScenario(facility, cardsToCreate) == (
			dcl createdCards: set of Card:= {};
			for all i in set dom cardsToCreate do (
				dcl newCard: Card := facility.registerCard(cardsToCreate(i), i);
				createdCards := createdCards union {newCard};
			);
			
			return createdCards;
		)
		post forall id in set dom cardsToCreate &
			(exists1 accessCard in set facility.facilityAccessCards & accessCard.id = id);
		
		-- Configure cards scenario
		public configureCardsScenario: Facility * set of nat ==> set of Card
		configureCardsScenario(facility, cardsToCreate) == (
			dcl createdCards: set of Card:= {};
			for all id in set cardsToCreate do (
				dcl newCard: Card := facility.registerCard(id);
				createdCards := createdCards union {newCard};
			);
			
			return createdCards;
		)
		post forall id in set cardsToCreate &
			(exists1 accessCard in set facility.facilityAccessCards & accessCard.id = id);
			
		-- Card removal scenario
		public cardRemoveScenario: Facility * nat ==> ()
		cardRemoveScenario(facility, cardID) == facility.removeCard(cardID);
		
		-- Configure card groups scenario
		public configureCardGroupsScenario: Facility * map CardGroup`CardGroupName to set of Card ==> set of CardGroup
		configureCardGroupsScenario(facility, cardGroupsInfo) == (
			dcl createdCardGroups: set of CardGroup := {};
			for all cardGroupName in set dom cardGroupsInfo do (
				dcl newCardGroup: CardGroup := facility.registerCardGroup(cardGroupName, cardGroupsInfo(cardGroupName));
				createdCardGroups := createdCardGroups union {newCardGroup};
			);
			
			return createdCardGroups;
		)
		post forall groupName in set dom cardGroupsInfo &
			(exists1 cardGroup in set facility.cardGroups & cardGroup.groupName = groupName);
			
		-- Card group removal scenario
		public removeCardGroupScenario: Facility * set of CardGroup`CardGroupName ==> set of CardGroup
		removeCardGroupScenario(facility, cardGroupsToRemoveNames) == (
			dcl removedCardGroups: set of CardGroup := {};
			for all cardGroupName in set cardGroupsToRemoveNames do (
				dcl removedCardGroup: CardGroup := facility.removeCardGroup(cardGroupName);
				removedCardGroups := removedCardGroups union {removedCardGroup};
			);
			
			return removedCardGroups;
		)
		pre forall groupName in set cardGroupsToRemoveNames & (exists group in set facility.cardGroups & group.groupName = groupName); 
		
		-- Card removal from card group scenario (given a card id and a card group name)
		public removeCardFromCardGroupScenario: Facility * map CardGroup`CardGroupName to set of nat ==> ()
		removeCardFromCardGroupScenario(facility, cardsToRemoveFromGroup) == (
			for all cardGroupName in set dom cardsToRemoveFromGroup do (
				for all accessCard in set cardsToRemoveFromGroup(cardGroupName) do facility.removeCardFromGroup(accessCard, cardGroupName);
			);
		);
		
		-- Card addition to card group scenario (given a card id and a card group name)
		public addCardToCardGroupScenario: Facility * CardGroup`CardGroupName * nat ==> ()
		addCardToCardGroupScenario(facility, cardGroupName, cardID) == (
			facility.addCardToGroup(cardID, cardGroupName);
		);
		
		-- Configure users scenario with given cards
		public configureUsersScenario: Facility * map User`UserName to (nat * Card) ==> set of User
		configureUsersScenario(facility, usersToCreateWithCard) == (
			dcl createdUsers: set of User := {};
			for all userName in set dom usersToCreateWithCard do (
				dcl newUser: User := facility.registerUser(userName, usersToCreateWithCard(userName).#1, usersToCreateWithCard(userName).#2);
				createdUsers := createdUsers union {newUser};
			);
			
			return createdUsers;
		)
		post RESULT subset facility.users and card RESULT = card dom usersToCreateWithCard;
		
		-- Configure users scenario where no card is given
		public configureUsersScenario: Facility * set of (User`UserName * nat) ==> set of User
		configureUsersScenario(facility, usersToCreate) == (
			dcl createdUsers: set of User := {};
			for all user in set usersToCreate do (
				dcl newUser: User := facility.registerUser(user.#1, user.#2);
				createdUsers := createdUsers union {newUser};
			);
			
			return createdUsers;
		)
		post RESULT subset facility.users and card RESULT = card usersToCreate;
		
		-- Configure sectors scenario, without parents
		public configureSectorsScenario: Facility * set of Sector`SectorID ==> set of Sector
		configureSectorsScenario(facility, sectorIDs) == (
			dcl createdSectors: set of Sector := {};
			for all sectorID in set sectorIDs do (
				dcl newSector: Sector := facility.registerSector(sectorID);
				createdSectors := createdSectors union {newSector};
			);
			
			return createdSectors;
		)
		post RESULT subset facility.sectors and card RESULT = card sectorIDs;
		
		-- Configure sectors scenario with parents
		public configureSectorsScenario: Facility * set of (Sector`SectorID * Sector) ==> set of Sector
		configureSectorsScenario(facility, sectorIDsAndParents) == (
			dcl createdSectors: set of Sector := {};
			for all sectorInfo in set sectorIDsAndParents do (
				dcl newSector: Sector := facility.registerSector(sectorInfo.#1, sectorInfo.#2);
				createdSectors := createdSectors union {newSector};
			);
			
			return createdSectors;
		)
		post RESULT subset facility.sectors and card RESULT = card sectorIDsAndParents;
		
		-- Remove sector scenario
		-- TODO
		
		-- Configure sector groups scenario
		-- TODO
		
		-- Ask for access scenario
		-- TODO
		
		public testSuccessfulConfiguration: Facility ==> ()
		testSuccessfulConfiguration(facility) == (
			dcl expirableCardsToCreate: map nat to DateUtil`Date := {
				0 |-> mk_DateUtil`Date(2014, 12, 18, 23, 55),
				1 |-> mk_DateUtil`Date(2014, 12, 17, 23, 55),
				2 |-> mk_DateUtil`Date(2014, 12, 16, 23, 55),
				3 |-> mk_DateUtil`Date(2014, 12, 15, 23, 55),
				4 |-> mk_DateUtil`Date(2014, 12, 14, 23, 55)
			};
			
			dcl normalCardsToCreate: set of nat := {5, 6, 7, 8, 9};
			
			dcl cardThatWillBeDeleted1: set of nat := {10};
			dcl cardThatWillBeDeleted2: set of nat := {11};
			dcl cardThatWillBeRemovedFromGroup: set of nat := {12};
			
			-- Register cards with a predefined expiration date
			dcl createdExpirableCards: set of Card := configureCardsScenario(facility, expirableCardsToCreate);
			
			-- Register cards without expiration date
			dcl createdNormalCards: set of Card := configureCardsScenario(facility, normalCardsToCreate);
			
			-- Register cards for future removal
			dcl cardToRemove1: set of Card := configureCardsScenario(facility, cardThatWillBeDeleted1);
			dcl cardToRemove2: set of Card := configureCardsScenario(facility, cardThatWillBeDeleted2);
			
			-- Register cards for future removal from group (not from the facility)
			dcl cardToRemoveFromGroup: set of Card := configureCardsScenario(facility, cardThatWillBeRemovedFromGroup);
			
			dcl cardGroupsToCreate: map CardGroup`CardGroupName to set of Card := {
				"staff" |-> createdNormalCards,
				"students" |-> createdExpirableCards,
				"removalByCardDeletion" |-> cardToRemove1 union cardToRemove2 union cardToRemoveFromGroup,
				"removalByCardDeletionWithCardIDAndGroupName" |-> cardToRemoveFromGroup,
				"manualRemoval" |-> cardToRemove2
			};
			
			-- Register card groups
			dcl staffCardGroup: set of CardGroup := configureCardGroupsScenario(facility, cardGroupsToCreate);
			
			-- Register cards to use with users
			dcl staffCard1: Card := facility.registerCard(13);
			dcl staffCard2: Card := facility.registerCard(14);
			dcl staffCard3: Card := facility.registerCard(15);
			
			dcl studentCard1: Card := facility.registerCard(mk_DateUtil`Date(2014, 12, 18, 23, 55), 16);
			dcl studentCard2: Card := facility.registerCard(mk_DateUtil`Date(2014, 12, 19, 23, 55), 17);
			dcl studentCard3: Card := facility.registerCard(mk_DateUtil`Date(2014, 12, 10, 23, 55), 18);
			
			dcl staffUsersToCreate: map User`UserName to (nat * Card) := { "staff1" |-> mk_(0, staffCard1),
				"staff2" |-> mk_(1, staffCard2),
				"staff3" |-> mk_(2, staffCard3) };
				
			dcl studentUsersToCreate: set of (User`UserName * nat) := { mk_("student1", 3), mk_("student2", 4), mk_("student3", 5)};
			
			-- Assert that the right number of cards were created
			assertEqual(card createdExpirableCards, card dom expirableCardsToCreate);
			assertEqual(card createdNormalCards, card normalCardsToCreate);
			
			-- Register staff users (with unexpirable cards)
			let staffUsers = configureUsersScenario(facility, staffUsersToCreate)
				in assertTrue(staffUsers subset facility.users);
				
			-- Register student users (without cards) and add cards later
			let studentUsers = configureUsersScenario(facility, studentUsersToCreate) in (
				dcl studentCardSequence: seq of Card := [studentCard1, studentCard2, studentCard3];
				assertTrue(studentUsers subset facility.users);
				
				-- Allocate cards to users
				for all student in set studentUsers do (
					facility.allocateCard(student, hd studentCardSequence);
					studentCardSequence := tl studentCardSequence;
				);
				
				-- Remove a card belonging to one of the users
				facility.removeCard(studentCard1);
				assertTrue(not exists user in set facility.users & user.accessCard = studentCard1);
				
				-- Remove exchange cards between two users
				let student2 = facility.getUserWithCard(17),
						student3 = facility.getUserWithCard(18) in (
						student3.removeAccessCard();
						facility.allocateCard(student2.id, 18);
						facility.allocateCard(student3.id, 17);
						
						assertTrue(student2.accessCard = studentCard3);
						assertTrue(student3.accessCard = studentCard2);
				);
				
				-- Create two users and remove them
				let userToRemove1 = facility.registerUser("removeMe1", 6),
					userToRemove2 = facility.registerUser("removeMe2", 7) in (
					facility.removeUser(userToRemove1);
					facility.removeUser(userToRemove2.id);
					
					assertTrue(userToRemove1 not in set facility.users);
					assertTrue(userToRemove2 not in set facility.users);
				);
			);
			
			-- Assert that the card groups were created and belong in the facility's card group sector
			assertTrue(staffCardGroup subset facility.cardGroups); 
			
			-- Remove a card from the group, given the card id and the group name. This should leave the "removalByCardDeletion" group with only 1 card left.
			removeCardFromCardGroupScenario(facility, { "removalByCardDeletion" |-> cardThatWillBeRemovedFromGroup });
			assertTrue(not exists group in set facility.cardGroups & (group.groupName = "removalByCardDeletion" and cardToRemoveFromGroup subset group.accessCards));
			
			-- Remove a card from the group, given the card id and the group name.
			-- This should cause the deletion of the "removalByCardDeletionWithCardIDAndGroupName" card group, since it had 1 card left
			removeCardFromCardGroupScenario(facility, { "removalByCardDeletionWithCardIDAndGroupName" |-> cardThatWillBeRemovedFromGroup });
			assertTrue(not exists group in set facility.cardGroups & (group.groupName = "removalByCardDeletionWithCardIDAndGroupName")); 
			
			-- Remove the sector group "manualRemoval" and check if it really was removed
			let removedCardGroups = removeCardGroupScenario(facility, {"manualRemoval"}) in assertTrue(not exists cardGroup in set removedCardGroups & cardGroup in set facility.cardGroups);
			assertTrue(not exists group in set facility.cardGroups & group.groupName = "manualRemoval");
			
			-- Remove a card. This should leave the "removalByCardDeletion" card group with 1 card left
			cardRemoveScenario(facility, 11);
			assertTrue(not exists accessCard in set facility.facilityAccessCards & accessCard.id = 11);
			assertTrue(not exists group in set facility.cardGroups & (group.groupName = "removalByCardDeletion" and cardToRemove2 subset group.accessCards));
			
			-- Remove a card. This should also remove the "removalByCardDeletion" card group, since it was the only card left
			cardRemoveScenario(facility, 10);
			assertTrue(not exists accessCard in set facility.facilityAccessCards & accessCard.id = 10);
			assertTrue(not exists group in set facility.cardGroups & group.groupName = "removalByCardDeletion");
			
			-- Manually add a card to a group
			addCardToCardGroupScenario(facility, "staff", 12);
			
			-- Create a few parent/main sectors
			let mainSectors = configureSectorsScenario(facility, {"classRooms", "secretariate", "garage"}) in (
				assertTrue(mainSectors subset facility.sectors);
			);
			
			-- Here we create some sectors that are children of the main sectors, including some that are children of children.
			let childSectors = configureSectorsScenario(facility, {
				mk_("classRoom1", facility.getSectorByID("classRooms")),
				mk_("classRoom2", facility.getSectorByID("classRooms")),
				mk_("classRoom3", facility.getSectorByID("classRooms"))
			}) union configureSectorsScenario(facility, {
				mk_("laboratory1", facility.getSectorByID("classRooms")),
				mk_("computer1", facility.getSectorByID("classRoom1")),
				mk_("parkingSpace1", facility.getSectorByID("garage")),
				mk_("parkingSpace2", facility.getSectorByID("garage")),
				mk_("parkingSpace3", facility.getSectorByID("garage"))
			}) in (
				assertTrue(childSectors subset facility.sectors);
				assertTrue(facility.getSectorByID("parkingSpace1").parent = facility.getSectorByID("garage"));
				assertTrue(facility.getSectorByID("parkingSpace2").parent = facility.getSectorByID("garage"));
				assertTrue(facility.getSectorByID("parkingSpace3").parent = facility.getSectorByID("garage"));
				assertTrue(facility.getSectorByID("computer1").parent = facility.getSectorByID("classRoom1"));
				assertTrue(facility.getSectorByID("laboratory1").parent = facility.getSectorByID("classRooms"));
				assertTrue(facility.getSectorByID("classRoom3").parent = facility.getSectorByID("classRooms"));
				assertTrue(facility.getSectorByID("classRoom2").parent = facility.getSectorByID("classRooms"));
				assertTrue(facility.getSectorByID("classRoom1").parent = facility.getSectorByID("classRooms"));
			);
		);
		
		-- Entry point to run tests
		public static testAll: () ==> ()
		testAll() == (
			dcl school : Facility := new Facility("school");
			dcl test: AccessPoliciesTest := new AccessPoliciesTest();
			test.testSuccessfulConfiguration(school);
		);
		
		-- This test breaks the no two cards with same id safety requirement
		public testFailedCardConfiguration: Facility ==> ()
		testFailedCardConfiguration(facility) == (
			dcl cards1: set of Card := configureCardsScenario(facility, {8});
			dcl cards2: set of Card := configureCardsScenario(facility, {8});
			return;
		);
		

end AccessPoliciesTest