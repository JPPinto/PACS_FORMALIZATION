class AccessPoliciesTest

	instance variables
		
	operations
		-- Simulates assertion checking by reducing it to pre-condition checking.
		-- If 'arg' does not hold, a pre-condition violation will be signaled.
		protected assertTrue: bool ==> ()
		assertTrue(arg) == return pre arg;

		-- Simulates assertion checking by reducing it to post-condition checking.
		-- If values are not equal, prints a message in the console and generates
		-- a post-conditions violation.
		protected assertEqual: ? * ? ==> ()
		assertEqual(expected, actual) == if expected <> actual then (
			IO`print("Actual value (");
			IO`print(actual);
			IO`print(") different from expected (");
			IO`print(expected);
			IO`println(")\n")
		)
		post expected = actual;
		
		-- Configure expirable cards scenario
		public configureCardsScenario: Facility * map nat to DateUtil`Date ==> set of Card
		configureCardsScenario(facility, cardsToCreate) == (
			dcl createdCards: set of Card:= {};
			for all i in set dom cardsToCreate do (
				dcl newCard: Card := facility.registerCard(cardsToCreate(i), i);
				createdCards := createdCards union {newCard};
			);
			
			return createdCards;
		)
		post forall id in set dom cardsToCreate &
			(exists1 accessCard in set facility.facilityAccessCards & accessCard.id = id);
		
		-- Configure cards scenario
		public configureCardsScenario: Facility * set of nat ==> set of Card
		configureCardsScenario(facility, cardsToCreate) == (
			dcl createdCards: set of Card:= {};
			for all id in set cardsToCreate do (
				dcl newCard: Card := facility.registerCard(id);
				createdCards := createdCards union {newCard};
			);
			
			return createdCards;
		)
		post forall id in set cardsToCreate &
			(exists1 accessCard in set facility.facilityAccessCards & accessCard.id = id);
			
		-- Card removal scenario
		public cardRemoveScenario: Facility * nat ==> ()
		cardRemoveScenario(facility, cardID) == facility.removeCard(cardID);
		
		-- Configure card groups scenario
		public configureCardGroupsScenario: Facility * map CardGroup`CardGroupName to set of Card ==> set of CardGroup
		configureCardGroupsScenario(facility, cardGroupsInfo) == (
			dcl createdCardGroups: set of CardGroup := {};
			for all cardGroupName in set dom cardGroupsInfo do (
				dcl newCardGroup: CardGroup := facility.registerCardGroup(cardGroupName, cardGroupsInfo(cardGroupName));
				createdCardGroups := createdCardGroups union {newCardGroup};
			);
			
			return createdCardGroups;
		)
		post forall groupName in set dom cardGroupsInfo &
			(exists1 cardGroup in set facility.cardGroups & cardGroup.groupName = groupName);
			
		-- Card group removal scenario
		public removeCardGroupScenario: Facility * set of CardGroup`CardGroupName ==> set of CardGroup
		removeCardGroupScenario(facility, cardGroupsToRemoveNames) == (
			dcl removedCardGroups: set of CardGroup := {};
			for all cardGroupName in set cardGroupsToRemoveNames do (
				dcl removedCardGroup: CardGroup := facility.removeCardGroup(cardGroupName);
				removedCardGroups := removedCardGroups union {removedCardGroup};
			);
			
			return removedCardGroups;
		)
		pre forall groupName in set cardGroupsToRemoveNames & (exists group in set facility.cardGroups & group.groupName = groupName); 
		
		-- Card removal from card group scenario (given a card id and a card group name)
		public removeCardFromCardGroupScenario: Facility * map CardGroup`CardGroupName to set of nat ==> ()
		removeCardFromCardGroupScenario(facility, cardsToRemoveFromGroup) == (
			for all cardGroupName in set dom cardsToRemoveFromGroup do (
				for all accessCard in set cardsToRemoveFromGroup(cardGroupName) do facility.removeCardFromGroup(accessCard, cardGroupName);
			);
		);
		
		-- Configure users scenario
		
		-- Configure sectors scenario
		
		-- Configure sector groups scenario
		
		-- Ask for access scenario
		
		
		public testSuccessfulConfiguration: Facility ==> ()
		testSuccessfulConfiguration(facility) == (
			dcl expirableCardsToCreate: map nat to DateUtil`Date := {
				0 |-> mk_DateUtil`Date(2014, 12, 18, 23, 55),
				1 |-> mk_DateUtil`Date(2014, 12, 17, 23, 55),
				2 |-> mk_DateUtil`Date(2014, 12, 16, 23, 55),
				3 |-> mk_DateUtil`Date(2014, 12, 15, 23, 55),
				4 |-> mk_DateUtil`Date(2014, 12, 14, 23, 55)
			};
			
			dcl normalCardsToCreate: set of nat := {5, 6, 7, 8, 9};
			
			dcl cardThatWillBeDeleted1: set of nat := {10};
			dcl cardThatWillBeDeleted2: set of nat := {11};
			dcl cardThatWillBeRemovedFromGroup: set of nat := {12};
			
			-- Register cards with a predefined expiration date
			dcl createdExpirableCards: set of Card := configureCardsScenario(facility, expirableCardsToCreate);
			
			-- Register cards without expiration date
			dcl createdNormalCards: set of Card := configureCardsScenario(facility, normalCardsToCreate);
			
			-- Register cards for future removal
			dcl cardToRemove1: set of Card := configureCardsScenario(facility, cardThatWillBeDeleted1);
			dcl cardToRemove2: set of Card := configureCardsScenario(facility, cardThatWillBeDeleted2);
			
			-- Register cards for future removal from group (not from the facility)
			dcl cardToRemoveFromGroup: set of Card := configureCardsScenario(facility, cardThatWillBeRemovedFromGroup);
			
			dcl cardGroupsToCreate: map CardGroup`CardGroupName to set of Card := {
				"staff" |-> createdNormalCards,
				"students" |-> createdExpirableCards,
				"removalByCardDeletion" |-> cardToRemove1 union cardToRemove2 union cardToRemoveFromGroup,
				"removalByCardDeletionWithCardIDAndGroupName" |-> cardToRemoveFromGroup,
				"manualRemoval" |-> cardToRemove2
			};
			
			-- Register card groups
			dcl staffCardGroup: set of CardGroup := configureCardGroupsScenario(facility, cardGroupsToCreate);
			
			-- Assert that the right number of cards were created
			assertEqual(card createdExpirableCards, card dom expirableCardsToCreate);
			assertEqual(card createdNormalCards, card normalCardsToCreate);
			
			-- Assert that the card groups were created and belong in the facility's card group sector
			assertTrue(staffCardGroup subset facility.cardGroups); 
			
			-- Remove a card from the group, given the card id and the group name. This should leave the "removalByCardDeletion" group with only 1 card left.
			removeCardFromCardGroupScenario(facility, { "removalByCardDeletion" |-> cardThatWillBeRemovedFromGroup });
			assertTrue(not exists group in set facility.cardGroups & (group.groupName = "removalByCardDeletion" and cardToRemoveFromGroup subset group.accessCards));
			
			-- Remove a card from the group, given the card id and the group name.
			-- This should cause the deletion of the "removalByCardDeletionWithCardIDAndGroupName" card group, since it had 1 card left
			removeCardFromCardGroupScenario(facility, { "removalByCardDeletionWithCardIDAndGroupName" |-> cardThatWillBeRemovedFromGroup });
			assertTrue(not exists group in set facility.cardGroups & (group.groupName = "removalByCardDeletionWithCardIDAndGroupName")); 
			
			-- Remove the sector group "manualRemoval" and check if it really was removed
			let removedCardGroups = removeCardGroupScenario(facility, {"manualRemoval"}) in assertTrue(not exists cardGroup in set removedCardGroups & cardGroup in set facility.cardGroups);
			assertTrue(not exists group in set facility.cardGroups & group.groupName = "manualRemoval");
			
			-- Remove a card. This should leave the "removalByCardDeletion" card group with 1 card left
			cardRemoveScenario(facility, 11);
			assertTrue(not exists accessCard in set facility.facilityAccessCards & accessCard.id = 11);
			assertTrue(not exists group in set facility.cardGroups & (group.groupName = "removalByCardDeletion" and cardToRemove2 subset group.accessCards));
			
			-- Remove a card. This should also remove the "removalByCardDeletion" card group, since it was the only card left
			cardRemoveScenario(facility, 10);
			assertTrue(not exists accessCard in set facility.facilityAccessCards & accessCard.id = 10);
			assertTrue(not exists group in set facility.cardGroups & group.groupName = "removalByCardDeletion");
		);
		
		-- Entry point to run tests
		public static testAll: () ==> ()
		testAll() == (
			dcl school : Facility := new Facility("school");
			dcl test: AccessPoliciesTest := new AccessPoliciesTest();
			test.testSuccessfulConfiguration(school);
		);
		
		-- This test breaks the no two cards with same id safety requirement
		public testFailedCardConfiguration: Facility ==> ()
		testFailedCardConfiguration(facility) == (
			dcl cards1: set of Card := configureCardsScenario(facility, {8});
			dcl cards2: set of Card := configureCardsScenario(facility, {8});
			return;
		);
		

end AccessPoliciesTest