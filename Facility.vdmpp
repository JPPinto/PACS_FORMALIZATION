class Facility

types
	public FacilityName = seq1 of char;

instance variables
	-- The set of all users currently registered in the facility
	public users: set of User := {};
	
	-- The set of all cards currently registered in the facility
	public facilityAccessCards: set of Card := {};
	
		-- The set of all card groups currently defined for the facility
	public cardGroups: set of CardGroup := {};
	
	-- The set of all sectors currently defined for the facility
	public sectors: set of Sector := {};
	
	-- The set of all sector groups currently defined for the facility
	public sectorGroups: set of SectorGroup := {};
	
	
	
		-- The set of all access rules currently defined for the facility
	public facilityAccessRules: set of AccessRule := {};
	
	-- The complete access log, represented as a set of access requests
	public accessLog: set of AccessRequest := {};
	
	public name: FacilityName;
	
	inv name <> "";
	
	-- Checks if there are no two users with the same card
	inv forall user in set users &
			(not exists user2 in set users &
				(user <> user2 and user.getAccessCard() <> nil and user.getAccessCard() = user2.getAccessCard()));
				
	-- Checks if there are no two users with the same id
	inv forall user in set users &
			(not exists user2 in set users & (user <> user2 and user.getID() = user2.getID()));
	
	-- Checks if there are no two cards with the same id
	inv forall accessCard in set facilityAccessCards &
			(not exists otherAccessCard in set facilityAccessCards &
				(accessCard <> otherAccessCard and accessCard.getID() = otherAccessCard.getID()));
	
	
operations

	public Facility: FacilityName ==> Facility
	Facility(facilityName) == (
		name := facilityName;
		
		return self
	)
	pre facilityName <> "";
	
	 -------------------------
	/**  User management  **/
 -------------------------
	
	-- Registers a user in the system, provided an access card
	public registerUser: User`UserName * nat * Card ==> User
	registerUser(username, id, accessCard) == (
		dcl newuser: User := new User(username, id, accessCard);
		users := users union {newuser};
		
		return newuser;
	)
	pre (not exists user in set users & user.id = id)
		and (not exists user in set users & user.accessCard = accessCard)
	post RESULT in set users;
	
	-- Registers a user in the system, no access card provided
	public registerUser: User`UserName * nat ==> User
	registerUser(username, id) == (
		dcl newuser: User := new User(username, id);
		users := users union {newuser};
		
		return newuser;
	)
	pre (not exists user in set users & user.id = id)
	post RESULT in set users;
	
	-- Removes a user from the system, given its ID
	public removeUser: nat ==> ()
	removeUser(userID) == (
		dcl user: User := iota u in set users & u.getID() = userID;
		removeUser(user);
	)
	pre exists u in set users & u.id = userID
	post not exists u in set users & u.id = userID;
	
	-- Removes a user from the system
	public removeUser: User ==> ()
	removeUser(user) == users := users \ {user}
	pre user in set users
	post user not in set users;
	
	 ----------------------
	/** Card management **/
 -----------------------
	
	-- Registers a card in the system with a given expiration date
	public registerCard: DateUtil`Date * nat ==> Card
	registerCard(doe, id) == (
		dcl accessCard: Card := new Card(doe, id);
		facilityAccessCards := facilityAccessCards union {accessCard};
		
		return accessCard;
	)
	pre (not exists accessCard in set facilityAccessCards & accessCard.id = id)
	post RESULT in set facilityAccessCards;
	
	-- Registes a card in the system
	public registerCard: nat ==> Card
	registerCard(id) == (
		dcl accessCard: Card := new Card(id);
		facilityAccessCards := facilityAccessCards union {accessCard};
		
		return accessCard;
	)
	pre (not exists accessCard in set facilityAccessCards & accessCard.id = id)
	post RESULT in set facilityAccessCards;
	
	-- Removes a given card from the facility, removing it from the user that may have it and any card groups it belongs to
	public removeCard: Card ==> ()
	removeCard(accessCard) == (
		if (exists u in set users & (u.accessCard = accessCard)) then (
			dcl user: User := getUserWithCard(accessCard);
			user.removeAccessCard();
		);
		removeCardFromAllGroups(accessCard);
		facilityAccessCards := facilityAccessCards \ {accessCard}
	)
	pre accessCard in set facilityAccessCards
	post accessCard not in set facilityAccessCards;
	
	-- Removes a card with the given ID from the facility, removing it from the user that may have it and any card groups it belongs to
	public removeCard: nat ==> ()
	removeCard(cardID) == (
		dcl accessCard: Card := iota c in set facilityAccessCards & c.getID() = cardID;
		removeCard(accessCard);
	)
	pre exists c in set facilityAccessCards & c.id = cardID
	post not exists c in set facilityAccessCards & c.id = cardID;
	
	-- Attributes a card to a user
	public allocateCard: User * Card ==> ()
	allocateCard(user, accessCard) == (
		user.setAcessCard(accessCard);
	)
	pre not exists u in set users & u.accessCard = accessCard
	post exists1 u in set users & u.accessCard = accessCard;
	
	-- Attributes a card to a user, given the user and card id
	public allocateCard: nat * nat ==> ()
	allocateCard(userID, accessCardID) == (
		dcl accessCard: Card := iota c in set facilityAccessCards & c.id = accessCardID;
		dcl user: User := iota u in set users & u.id = userID;
		user.setAcessCard(accessCard);
	)
	pre not exists u in set users & (u.id = userID and u.accessCard.id = accessCardID)
	post exists1 u in set users & (u.id = userID and u.accessCard.id = accessCardID);
	
	-- Returns the user with a given card
	public getUserWithCard: Card ==> User
	getUserWithCard(accessCard) == (
		return iota user in set users & user.accessCard = accessCard;
	)
	pre exists u in set users & u.accessCard = accessCard;
	
	-- Returns the user with a card with a matching id
	public getUserWithCard: nat ==> User
	getUserWithCard(accessCardID) == (
		dcl accessCard: Card := iota c in set facilityAccessCards & c.id = accessCardID;
		return getUserWithCard(accessCard);
	)
	pre exists u in set users & (u.accessCard.id = accessCardID);
	
	 -----------------------------
	/** Card group management **/
 -----------------------------
 
 -- Register a new card group
 -- There cannot exist two card groups with the same name
 public registerCardGroup: CardGroup`CardGroupName * set of Card ==> CardGroup
 registerCardGroup(groupName, accessCards) == (
 		dcl newCardGroup: CardGroup := new CardGroup(groupName, accessCards);
 		cardGroups := cardGroups union {newCardGroup};
 		
 		return newCardGroup;
 )
 pre groupName <> ""
 	and not exists cardGroup in set cardGroups & cardGroup.groupName = groupName
 post exists1 cardGroup in set cardGroups & cardGroup.groupName = groupName;
 
 -- Removes a card group from the system, given its name
	public removeCardGroup: CardGroup`CardGroupName ==> ()
	removeCardGroup(groupName) == (
		dcl group: CardGroup := iota g in set cardGroups & g.groupName = groupName;
		removeCardGroup(group);
	)
	pre exists g in set cardGroups & g.groupName = groupName
	post not exists g in set cardGroups & g.groupName = groupName;
	
	-- Removes a card group from the system
	public removeCardGroup: CardGroup ==> ()
	removeCardGroup(group) == cardGroups := cardGroups \ {group}
	pre group in set cardGroups
	post group not in set cardGroups;
 
 -- Removes a card from a group, given a card id and a group name
 -- The given group must contain the card, and if the group would be left empty, it must be removed
 public removeCardFromGroup: nat * CardGroup`CardGroupName ==> ()
 removeCardFromGroup(cardID, groupName) == (
	dcl cardGroup: CardGroup := iota g in set cardGroups & g.groupName = groupName;
	dcl accessCard: Card := iota c in set facilityAccessCards & c.id = cardID;
	if(card cardGroup.accessCards > 1) then cardGroup.removeCard(accessCard)
 	else removeCardGroup(cardGroup);
 )
 pre (exists g in set cardGroups & (g.groupName = groupName and exists c in set g.accessCards & c.id = cardID))
 post not exists g in set cardGroups & (g.groupName = groupName and exists c in set g.accessCards & c.id = cardID);
 
 -- Removes a card from a group, given a card and a group
 -- The given group must contain the card, and if the group would be left empty, it must be removed
 public removeCardFromGroup: Card * CardGroup ==> ()
 removeCardFromGroup(accessCard, cardGroup) == (
 	if(card cardGroup.accessCards > 1) then cardGroup.removeCard(accessCard)
 	else removeCardGroup(cardGroup);
 )
 pre accessCard in set cardGroup.accessCards
 post (accessCard not in set cardGroup.accessCards) or (cardGroup not in set cardGroups);
 
  -- Removes a card from all groups.
 public removeCardFromAllGroups: Card ==> ()
 removeCardFromAllGroups(accessCard) == (
 	for all cardGroup in set cardGroups do (
 		if cardGroup.containsCard(accessCard) then removeCardFromGroup(accessCard, cardGroup);
 	);
 );
 
	 ----------------------------------
	/** Access rules and requesting **/
 -----------------------------------
	
	-- Returns all rules that have influence in a given sector, for a given access card
	public getRelatedRules: Card * Sector ==> set of AccessRule
	getRelatedRules(accessCard, accessedSector) == (
		dcl relatedRules: set of AccessRule := {};
		for all rule in set facilityAccessRules do (
			if rule.ruleRefersToAccessCardAndSector(accessCard, accessedSector) then relatedRules := relatedRules union {rule};
		);
		
		return relatedRules;
	);
	
	-- Requests access given a requesting user, the sector access has been requested to, and the date of request
	public requestAccess: User * Sector * DateUtil`Date ==> AccessRule`Permission * AccessRequest
	requestAccess(requester, sector, requestDate) == (
		dcl relatedRules: set of AccessRule := getRelatedRules(requester.getAccessCard(), sector);
		dcl highestPriorityRule: AccessRule := AccessRule`getHighestPriorityValidRuleFromSet(relatedRules, requestDate);
		dcl finalResult: AccessRule`Permission := highestPriorityRule.getPermission();
		
		dcl loggedRequest: AccessRequest :=
			new AccessRequest(requester, requester.getAccessCard(), sector, highestPriorityRule, finalResult, requestDate);
		
		accessLog := accessLog union {loggedRequest};
		
		return mk_(finalResult, loggedRequest);
	)
	pre requester in set users 

traces
-- TODO Define Combinatorial Test Traces here
end Facility